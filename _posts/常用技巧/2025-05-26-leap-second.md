---
title: GNSS 的周内秒如何转为 UTC 时间?
category: [常用技巧]
tags: [UTC, leap second, 闰秒, 周内秒]
---

> 一般情况下， GNSS 的周内秒是来自于原子时的不断累加, 而 UTC 则是天文时间，和地球的自转时间有关，由于地球的自转时间不规则，UTC 时间和原子时之间存在一个误差，截至目前，UTC 时间比原子时慢了 18 秒，所以在使用 GNSS 的周内秒时，常常需要将其转换为 UTC 时间，下面有一个很简单的例子，可以按照这种思维方式来实现转换。
{: .prompt-info }

## 引子

小熊有两块秒表 A，B；A 秒表从 0 数到 59 后又会从 0 开始计时，B 秒表也是如此，但是 B 秒表永远比 A 秒表慢 18 秒，已知 A 秒表的读数，请求出 B 秒表的读数。

### 问题分析

当 A 的读数为 a 时，B 的读数应为 (a - 18) 秒。如果结果为负数，则需要加上 60 使其回到 0-59 的范围内。

### 处理思路

使用模运算来处理循环问题。表达式 (a - 18 + 60) % 60 确保无论 a 的大小如何，结果都落在 0 到 59 之间。

### 代码实现

```c++
#include <stdio.h>

int main() {
    int a;
    scanf("%d", &a);
    int b = (a - 18 + 60) % 60;
    printf("%d\n", b);
    return 0;
}
```

## 周内秒
周内秒的值范围是 [0, 604800) 累计，再从 0 开始循环以往。

### 代码实现

```c++
#include <stdio.h>

int main() {
    unsigned int a;
    scanf("%d", &a);
    unsigned int b = (a + 604800 - 18) % 604800;
    printf("%d\n", b);
    printf("H: %d\n", (b / 3600) % 24);
    printf("M: %d\n", (b / 60) % 60);
    printf("S: %d\n", b % 60);
    return 0;
}
```